<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ED3 Video Editor Preview</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 16px; }
    .container { max-width: 1000px; margin: 0 auto; }
    #viewer { width: 100%; height: 560px; background: #111; display:flex; align-items:center; justify-content:center; overflow:hidden; position:relative; }
    #viewer .bg { position:absolute; inset:0; background-size:cover; background-position:center; filter: blur(24px) saturate(1.05); transform: scale(1.08); z-index:1; }
    /* media variants: fit (cover) or nofit (contain / natural size) */
    #viewer.fit img.media, #viewer.fit video.media {
      position:relative;
      z-index:2;
      width:100%;
      height:100%;
      object-fit:cover;
      transform-origin:center center;
      transform: translate(0,0) scale(1);
      transition: transform 0.05s linear;
      display:block;
      background: transparent;
    }
    #viewer.nofit img.media, #viewer.nofit video.media {
      position:relative;
      z-index:2;
      width:auto;
      height:auto;
      max-width:90%;
      max-height:90%;
      object-fit:contain;
      transform-origin:center center;
      transform: translate(0,0) scale(1);
      transition: transform 0.05s linear;
      display:block;
      background: transparent;
    }
    .controls { margin-top:12px; }
    .controls > * { margin-right:8px; }
    #jsonBox { width:100%; height:120px; margin-top:8px; }
    .status { margin-top:8px; color:#444; }
  </style>
</head>
<body>
  <div class="container">
    <h2>ED3 Video Editor Preview</h2>

    <div>
      <label>Media (images or videos; select multiple): <input id="imagesInput" type="file" accept="image/*,video/*" multiple></label>
    </div>

    <div style="margin-top:8px;">
      <label>.ed3 file (audio + timeline): <input id="ed3Input" type="file" accept=".ed3,.mp3"></label>
    </div>

    <div id="viewer" class="fit">
      <div id="bg" class="bg" aria-hidden="true"></div>
      <img id="displayImg" class="media" src="" alt="no image loaded" />
      <video id="displayVideo" class="media" src="" playsinline muted style="display:none"></video>
    </div>

    <div class="controls">
      <button id="startBtn" disabled>Start Preview</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="stopBtn" disabled>Stop</button>
      <label style="margin-left:8px"><input id="fitToggle" type="checkbox" checked> Fit to Fill</label>
      <label style="margin-left:8px"><input id="shakeToggle" type="checkbox" checked> Shake</label>
      <label style="margin-left:8px"><input id="zoomToggle" type="checkbox" checked> Zoom</label>
      <label style="margin-left:8px">Zoom to: <input id="zoomAmount" type="number" step="0.01" value="1.08" style="width:80px">x</label>
      <label style="margin-left:8px">Zoom ms: <input id="zoomDuration" type="number" value="600" style="width:80px">ms</label>
      <label style="margin-left:12px">Resolution:
        <select id="resolutionSelect">
          <option value="1280x720">1280×720 (16:9)</option>
          <option value="1920x1080">1920×1080 (16:9)</option>
          <option value="720x1280">720×1280 (9:16)</option>
          <option value="1080x1920">1080×1920 (9:16)</option>
          <option value="custom">Custom</option>
        </select>
      </label>
      <label id="customRes" style="display:none; margin-left:8px">W: <input id="customW" type="number" value="1280" style="width:80px"> H: <input id="customH" type="number" value="720" style="width:80px"></label>
      <button id="copyJsonBtn" disabled>Copy JSON</button>
      <span id="timeLabel" style="margin-left:12px;">00:00</span>
    </div>

    <textarea id="jsonBox" aria-label="Embedded JSON" placeholder='Embedded JSON will appear here...' readonly></textarea>
    <div class="status" id="status">No files loaded.</div>

    <audio id="audio" crossorigin="anonymous"></audio>
  </div>

  <script>
    const MARKER = '\n--ED3-JSON-START--\n';
    const imagesInput = document.getElementById('imagesInput');
    const ed3Input = document.getElementById('ed3Input');
    const displayImg = document.getElementById('displayImg');
    const displayVideo = document.getElementById('displayVideo');
    const bgDiv = document.getElementById('bg');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const resolutionSelect = document.getElementById('resolutionSelect');
    const customResLabel = document.getElementById('customRes');
    const customW = document.getElementById('customW');
    const customH = document.getElementById('customH');
    const zoomToggle = document.getElementById('zoomToggle');
    const zoomAmountInput = document.getElementById('zoomAmount');
    const zoomDurationInput = document.getElementById('zoomDuration');
    const jsonBox = document.getElementById('jsonBox');
    const status = document.getElementById('status');
    const audio = document.getElementById('audio');
    const timeLabel = document.getElementById('timeLabel');
    const shakeToggle = document.getElementById('shakeToggle');
    const fitToggle = document.getElementById('fitToggle');

    // target output/viewer size (pixels)
    let targetW = 1280;
    let targetH = 720;
    const viewer = document.getElementById('viewer');

    // zoom state
    let zoomUntil = 0;
    let zoomStart = 0;
    let zoomDurationMs = Number(zoomDurationInput.value || 600);
    let zoomTarget = Number(zoomAmountInput.value || 1.08);
    let zoomActive = false;

    function applyResolution(w, h) {
      targetW = Math.max(16, Math.round(Number(w) || 1280));
      targetH = Math.max(16, Math.round(Number(h) || 720));
      // set viewer pixel size to selected resolution (clamped to reasonable max)
      const maxW = Math.min(targetW, window.innerWidth - 40);
      const maxH = Math.min(targetH, window.innerHeight - 140);
      viewer.style.width = maxW + 'px';
      viewer.style.height = maxH + 'px';
      // ensure background covers
      bgDiv.style.backgroundSize = 'cover';
    }

    // handle preset/custom resolution UI
    resolutionSelect.addEventListener('change', () => {
      const val = resolutionSelect.value;
      if (val === 'custom') {
        customResLabel.style.display = 'inline-block';
        applyResolution(customW.value, customH.value);
      } else {
        customResLabel.style.display = 'none';
        const [w,h] = val.split('x').map(Number);
        customW.value = w; customH.value = h;
        applyResolution(w,h);
      }
    });
    customW.addEventListener('input', () => applyResolution(customW.value, customH.value));
    customH.addEventListener('input', () => applyResolution(customW.value, customH.value));

    // initialize
    applyResolution(targetW, targetH);

    // apply initial fit setting and hook toggle
    function applyFitMode() {
      const viewerEl = document.getElementById('viewer');
      if (fitToggle.checked) {
        viewerEl.classList.add('fit');
        viewerEl.classList.remove('nofit');
      } else {
        viewerEl.classList.add('nofit');
        viewerEl.classList.remove('fit');
      }
    }
    fitToggle.addEventListener('change', () => applyFitMode());
    applyFitMode();

    let media = []; // array of {file, url, type: 'image'|'video'}
    let timeline = [];
    let mp3Blob = null;
    let currentIndex = -1;
    let rafId = null;
    let shakeUntil = 0;
    // update zoom inputs when changed
    zoomAmountInput.addEventListener('input', () => { zoomTarget = Number(zoomAmountInput.value) || 1.0; });
    zoomDurationInput.addEventListener('input', () => { zoomDurationMs = Math.max(0, Number(zoomDurationInput.value) || 600); });

    imagesInput.addEventListener('change', async () => {
      media = [];
      const files = Array.from(imagesInput.files || []);
      for (const f of files) {
        try {
          const url = URL.createObjectURL(f);
          const type = (f.type && f.type.startsWith('video')) ? 'video' : 'image';
          // don't block UI waiting for load; for images we ensure they load to avoid broken displays
          if (type === 'image') {
            const img = new Image();
            await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
          }
          media.push({file: f, url, type});
        } catch (e) {
          console.warn('Failed load media', f.name, e);
        }
      }
      if (media.length) {
        // show first media (don't autoplay when just loading files)
        showMedia(media[0], false);
        status.textContent = `${media.length} media files loaded.`;
      } else {
        displayImg.src = '';
        displayVideo.src = '';
        bgDiv.style.backgroundImage = '';
        status.textContent = 'No media loaded.';
      }
      updateControls();
    });

    ed3Input.addEventListener('change', async () => {
      const f = ed3Input.files && ed3Input.files[0];
      if (!f) return;
      try {
        const buffer = await readFileAsArrayBuffer(f);
        const markerBytes = new TextEncoder().encode(MARKER);
        const idx = indexOfSequence(new Uint8Array(buffer), markerBytes);
        if (idx >= 0) {
          const mp3Bytes = buffer.slice(0, idx);
          const jsonBytes = buffer.slice(idx + markerBytes.length);
          const jsonText = new TextDecoder().decode(jsonBytes);
          jsonBox.value = jsonText;
          try {
            const parsed = JSON.parse(jsonText);
            timeline = parseTimelineObj(parsed);
            status.textContent = `Loaded timeline with ${timeline.length} entries.`;
          } catch (e) {
            timeline = [];
            status.textContent = 'Failed to parse embedded JSON.';
            console.error(e);
          }
          mp3Blob = new Blob([mp3Bytes], {type:'audio/mpeg'});
          copyJsonBtn.disabled = false;
        } else {
          // fallback: if file is pure mp3
          mp3Blob = new Blob([buffer], {type:'audio/mpeg'});
          jsonBox.value = '';
          timeline = [];
          status.textContent = 'No embedded JSON marker found; treated as MP3 only.';
          copyJsonBtn.disabled = true;
        }
      } catch (e) {
        console.error(e);
        status.textContent = 'Error reading .ed3 file.';
      }
      updateControls();
    });

    copyJsonBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(jsonBox.value);
        status.textContent = 'JSON copied to clipboard.';
      } catch (e) {
        console.warn(e);
        status.textContent = 'Copy failed.';
      }
    });

    startBtn.addEventListener('click', () => {
      if (!mp3Blob) return;
      if (!media.length) { status.textContent = 'No media loaded.'; return; }
      audio.src = URL.createObjectURL(mp3Blob);
      audio.currentTime = 0;
      audio.play();
      currentIndex = -1;
      shakeUntil = 0;
      startRaf();
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      status.textContent = 'Playing...';
    });

    pauseBtn.addEventListener('click', () => {
      if (audio.paused) {
        audio.play();
        pauseBtn.textContent = 'Pause';
      } else {
        audio.pause();
        pauseBtn.textContent = 'Resume';
      }
    });

    stopBtn.addEventListener('click', stopPlayback);

    audio.addEventListener('ended', () => {
      stopPlayback();
    });

    function stopPlayback() {
      audio.pause();
      audio.currentTime = 0;
      cancelRaf();
      currentIndex = -1;
      displayImg.style.transform = '';
      bgDiv.style.backgroundImage = '';
      displayVideo.style.display = 'none';
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pause';
      stopBtn.disabled = true;
      status.textContent = 'Stopped.';
    }

    function updateControls() {
      const canStart = !!mp3Blob && media.length > 0 && timeline.length > 0;
      startBtn.disabled = !canStart;
      pauseBtn.disabled = !canStart;
      stopBtn.disabled = !canStart;
    }

    function startRaf() {
      if (rafId) return;
      function loop() {
        const t = audio.currentTime;
        timeLabel.textContent = formatTime(t);
        // find last timeline index <= t
        let idx = -1;
        for (let i = 0; i < timeline.length; i++) {
          if (timeline[i] <= t) idx = i; else break;
        }
        if (idx !== currentIndex) {
          currentIndex = idx;
          if (currentIndex >= 0) {
            const mediaObj = media[currentIndex % media.length];
            // show and play video if it's a video
            showMedia(mediaObj, true);
            const now = performance.now();
            // start shake if enabled
            if (shakeToggle.checked) shakeUntil = now + 600;
            // start zoom if enabled
            if (zoomToggle.checked) {
              zoomStart = now;
              zoomDurationMs = Math.max(0, Number(zoomDurationInput.value) || 600);
              zoomTarget = Math.max(1.0, Number(zoomAmountInput.value) || 1.0);
              zoomUntil = zoomStart + zoomDurationMs;
              zoomActive = true;
            } else {
              zoomActive = false;
              zoomUntil = 0;
            }
          }
        }
        // compute shake offsets
        let ox = 0, oy = 0;
        const nowPerf = performance.now();
        if (nowPerf < shakeUntil && shakeToggle.checked) {
          const amp = 8;
          ox = Math.floor((Math.random() * (amp*2+1)) - amp);
          oy = Math.floor((Math.random() * (amp*2+1)) - amp);
        }
        // compute zoom scale: smooth from 1 to zoomTarget, and remain at zoomTarget after completion
        let scale = 1.0;
        if (zoomActive && zoomToggle.checked) {
          if (nowPerf < zoomStart) {
            scale = 1.0;
          } else if (nowPerf < zoomUntil) {
            const progress = Math.max(0, Math.min(1, (nowPerf - zoomStart) / Math.max(1, zoomDurationMs)));
            scale = 1 + (zoomTarget - 1) * progress;
          } else {
            // keep final zoom
            scale = zoomTarget;
          }
        }
        // apply combined transform (translate + scale) to visible element
        const transform = `translate(${ox}px, ${oy}px) scale(${scale})`;
        if (displayVideo.style.display !== 'none') {
          displayVideo.style.transform = transform;
        } else {
          displayImg.style.transform = transform;
        }
        rafId = requestAnimationFrame(loop);
      }
      rafId = requestAnimationFrame(loop);
    }

    function cancelRaf() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsArrayBuffer(file);
      });
    }

    function indexOfSequence(data, pattern) {
      // data, pattern are Uint8Array
      const d = data;
      const p = pattern;
      if (p.length === 0) return 0;
      outer: for (let i = 0; i <= d.length - p.length; i++) {
        for (let j = 0; j < p.length; j++) {
          if (d[i + j] !== p[j]) continue outer;
        }
        return i;
      }
      return -1;
    }

    function parseTimelineObj(parsed) {
      // expected { "timeline": [ {"time":0.0}, ... ] }
      if (!parsed || !parsed.timeline || !Array.isArray(parsed.timeline)) return [];
      const arr = parsed.timeline.map(e => Number(e.time || 0)).filter(n => !Number.isNaN(n));
      arr.sort((a,b)=>a-b);
      return arr;
    }

    function formatTime(t) {
      const s = Math.floor(t % 60).toString().padStart(2,'0');
      const m = Math.floor(t/60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    async function showMedia(mediaObj, playNow = false) {
      // stop any playing foreground video
      try { displayVideo.pause(); } catch(_) {}
      displayVideo.style.transform = '';
      displayImg.style.transform = '';

      // reset video source to avoid background playback
      displayVideo.src = '';
      displayVideo.style.display = 'none';

      if (mediaObj.type === 'video') {
        displayVideo.src = mediaObj.url;
        displayVideo.style.display = 'block';
        displayImg.style.display = 'none';
        displayVideo.currentTime = 0;

        // capture a frame for the blurred background at target resolution (cover)
        try {
          await new Promise((res) => {
            const onLoaded = () => { displayVideo.removeEventListener('loadeddata', onLoaded); res(); };
            displayVideo.addEventListener('loadeddata', onLoaded);
            if (displayVideo.readyState >= 2) res();
          });
          const canvas = document.createElement('canvas');
          canvas.width = targetW; canvas.height = targetH;
          const ctx = canvas.getContext('2d');
          // draw video frame covering the canvas (cover)
          const vw = displayVideo.videoWidth || targetW;
          const vh = displayVideo.videoHeight || targetH;
          const scale = Math.max(targetW / vw, targetH / vh);
          const dw = vw * scale, dh = vh * scale;
          const dx = (targetW - dw) / 2, dy = (targetH - dh) / 2;
          ctx.clearRect(0,0,targetW,targetH);
          ctx.drawImage(displayVideo, 0, 0, vw, vh, dx, dy, dw, dh);
          try { const dataUrl = canvas.toDataURL('image/jpeg'); bgDiv.style.backgroundImage = `url('${dataUrl}')`; } catch(e) { bgDiv.style.backgroundImage = ''; }
        } catch (e) {
          bgDiv.style.backgroundImage = '';
        }

        if (playNow) {
          displayVideo.muted = true; // keep it muted (audio from .ed3)
          const p = displayVideo.play();
          if (p && p.catch) p.catch(() => {});
        }
      } else {
        displayImg.src = mediaObj.url;
        displayImg.style.display = 'block';
        displayVideo.style.display = 'none';
        // create a canvas and draw the image scaled to target resolution for blurred background
        try {
          const img = new Image();
          await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = mediaObj.url; });
          const canvas = document.createElement('canvas');
          canvas.width = targetW; canvas.height = targetH;
          const ctx = canvas.getContext('2d');
          const iw = img.width, ih = img.height;
          const scale = Math.max(targetW / iw, targetH / ih);
          const dw = iw * scale, dh = ih * scale;
          const dx = (targetW - dw) / 2, dy = (targetH - dh) / 2;
          ctx.clearRect(0,0,targetW,targetH);
          ctx.drawImage(img, dx, dy, dw, dh);
          try { const dataUrl = canvas.toDataURL('image/jpeg'); bgDiv.style.backgroundImage = `url('${dataUrl}')`; } catch(e) { bgDiv.style.backgroundImage = ''; }
        } catch (e) {
          bgDiv.style.backgroundImage = `url('${mediaObj.url}')`;
        }
      }
    }

    // keep JSON textarea selectable
    jsonBox.addEventListener('click', () => jsonBox.select());
  </script>
</body>
</html>
