<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ED3 Video Editor Preview</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 16px; }
    .container { max-width: 1000px; margin: 0 auto; }
    #viewer { width: 100%; height: 560px; background: #111; display:flex; align-items:center; justify-content:center; overflow:hidden; position:relative; }
    #viewer .bg { position:absolute; inset:0; background-size:cover; background-position:center; filter: blur(24px) saturate(1.05); transform: scale(1.08); z-index:1; }
    #viewer img { position:relative; z-index:2; max-width:90%; max-height:90%; transform: translate(0,0); transition: transform 0.05s linear; }
    .controls { margin-top:12px; }
    .controls > * { margin-right:8px; }
    #jsonBox { width:100%; height:120px; margin-top:8px; }
    .status { margin-top:8px; color:#444; }
  </style>
</head>
<body>
  <div class="container">
    <h2>ED3 Video Editor Preview</h2>

    <div>
      <label>Images (select multiple): <input id="imagesInput" type="file" accept="image/*" multiple></label>
    </div>

    <div style="margin-top:8px;">
      <label>.ed3 file (audio + timeline): <input id="ed3Input" type="file" accept=".ed3,.mp3"></label>
    </div>

    <div id="viewer">
      <div id="bg" class="bg" aria-hidden="true"></div>
      <img id="displayImg" src="" alt="no image loaded" />
    </div>

    <div class="controls">
      <button id="startBtn" disabled>Start Preview</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="copyJsonBtn" disabled>Copy JSON</button>
      <span id="timeLabel" style="margin-left:12px;">00:00</span>
    </div>

    <textarea id="jsonBox" aria-label="Embedded JSON" placeholder='Embedded JSON will appear here...' readonly></textarea>
    <div class="status" id="status">No files loaded.</div>

    <audio id="audio" crossorigin="anonymous"></audio>
  </div>

  <script>
    const MARKER = '\n--ED3-JSON-START--\n';
    const imagesInput = document.getElementById('imagesInput');
    const ed3Input = document.getElementById('ed3Input');
    const displayImg = document.getElementById('displayImg');
    const bgDiv = document.getElementById('bg');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const jsonBox = document.getElementById('jsonBox');
    const status = document.getElementById('status');
    const audio = document.getElementById('audio');
    const timeLabel = document.getElementById('timeLabel');

    let images = [];
    let timeline = [];
    let mp3Blob = null;
    let currentIndex = -1;
    let rafId = null;
    let shakeUntil = 0;

    imagesInput.addEventListener('change', async () => {
      images = [];
      const files = Array.from(imagesInput.files || []);
      for (const f of files) {
        try {
          const url = URL.createObjectURL(f);
          const img = new Image();
          await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
          images.push({file: f, url});
        } catch (e) {
          console.warn('Failed load image', f.name, e);
        }
      }
      if (images.length) {
        displayImg.src = images[0].url;
        bgDiv.style.backgroundImage = `url('${images[0].url}')`;
        status.textContent = `${images.length} images loaded.`;
      } else {
        displayImg.src = '';
        bgDiv.style.backgroundImage = '';
        status.textContent = 'No images loaded.';
      }
      updateControls();
    });

    ed3Input.addEventListener('change', async () => {
      const f = ed3Input.files && ed3Input.files[0];
      if (!f) return;
      try {
        const buffer = await readFileAsArrayBuffer(f);
        const markerBytes = new TextEncoder().encode(MARKER);
        const idx = indexOfSequence(new Uint8Array(buffer), markerBytes);
        if (idx >= 0) {
          const mp3Bytes = buffer.slice(0, idx);
          const jsonBytes = buffer.slice(idx + markerBytes.length);
          const jsonText = new TextDecoder().decode(jsonBytes);
          jsonBox.value = jsonText;
          try {
            const parsed = JSON.parse(jsonText);
            timeline = parseTimelineObj(parsed);
            status.textContent = `Loaded timeline with ${timeline.length} entries.`;
          } catch (e) {
            timeline = [];
            status.textContent = 'Failed to parse embedded JSON.';
            console.error(e);
          }
          mp3Blob = new Blob([mp3Bytes], {type:'audio/mpeg'});
          copyJsonBtn.disabled = false;
        } else {
          // fallback: if file is pure mp3
          mp3Blob = new Blob([buffer], {type:'audio/mpeg'});
          jsonBox.value = '';
          timeline = [];
          status.textContent = 'No embedded JSON marker found; treated as MP3 only.';
          copyJsonBtn.disabled = true;
        }
      } catch (e) {
        console.error(e);
        status.textContent = 'Error reading .ed3 file.';
      }
      updateControls();
    });

    copyJsonBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(jsonBox.value);
        status.textContent = 'JSON copied to clipboard.';
      } catch (e) {
        console.warn(e);
        status.textContent = 'Copy failed.';
      }
    });

    startBtn.addEventListener('click', () => {
      if (!mp3Blob) return;
      if (!images.length) { status.textContent = 'No images loaded.'; return; }
      audio.src = URL.createObjectURL(mp3Blob);
      audio.currentTime = 0;
      audio.play();
      currentIndex = -1;
      shakeUntil = 0;
      startRaf();
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      status.textContent = 'Playing...';
    });

    pauseBtn.addEventListener('click', () => {
      if (audio.paused) {
        audio.play();
        pauseBtn.textContent = 'Pause';
      } else {
        audio.pause();
        pauseBtn.textContent = 'Resume';
      }
    });

    stopBtn.addEventListener('click', stopPlayback);

    audio.addEventListener('ended', () => {
      stopPlayback();
    });

    function stopPlayback() {
      audio.pause();
      audio.currentTime = 0;
      cancelRaf();
      currentIndex = -1;
      displayImg.style.transform = '';
      bgDiv.style.backgroundImage = '';
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pause';
      stopBtn.disabled = true;
      status.textContent = 'Stopped.';
    }

    function updateControls() {
      const canStart = !!mp3Blob && images.length > 0 && timeline.length > 0;
      startBtn.disabled = !canStart;
      pauseBtn.disabled = !canStart;
      stopBtn.disabled = !canStart;
    }

    function startRaf() {
      if (rafId) return;
      function loop() {
        const t = audio.currentTime;
        timeLabel.textContent = formatTime(t);
        // find last timeline index <= t
        let idx = -1;
        for (let i = 0; i < timeline.length; i++) {
          if (timeline[i] <= t) idx = i; else break;
        }
        if (idx !== currentIndex) {
          currentIndex = idx;
          if (currentIndex >= 0) {
            const imgObj = images[currentIndex % images.length];
            displayImg.src = imgObj.url;
            bgDiv.style.backgroundImage = `url('${imgObj.url}')`;
            // start shake
            shakeUntil = performance.now() + 600;
          }
        }
        // apply shake
        if (performance.now() < shakeUntil) {
          const amp = 8;
          const ox = Math.floor((Math.random() * (amp*2+1)) - amp);
          const oy = Math.floor((Math.random() * (amp*2+1)) - amp);
          displayImg.style.transform = `translate(${ox}px, ${oy}px)`;
        } else {
          displayImg.style.transform = '';
        }
        rafId = requestAnimationFrame(loop);
      }
      rafId = requestAnimationFrame(loop);
    }

    function cancelRaf() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsArrayBuffer(file);
      });
    }

    function indexOfSequence(data, pattern) {
      // data, pattern are Uint8Array
      const d = data;
      const p = pattern;
      if (p.length === 0) return 0;
      outer: for (let i = 0; i <= d.length - p.length; i++) {
        for (let j = 0; j < p.length; j++) {
          if (d[i + j] !== p[j]) continue outer;
        }
        return i;
      }
      return -1;
    }

    function parseTimelineObj(parsed) {
      // expected { "timeline": [ {"time":0.0}, ... ] }
      if (!parsed || !parsed.timeline || !Array.isArray(parsed.timeline)) return [];
      const arr = parsed.timeline.map(e => Number(e.time || 0)).filter(n => !Number.isNaN(n));
      arr.sort((a,b)=>a-b);
      return arr;
    }

    function formatTime(t) {
      const s = Math.floor(t % 60).toString().padStart(2,'0');
      const m = Math.floor(t/60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    // keep JSON textarea selectable
    jsonBox.addEventListener('click', () => jsonBox.select());
  </script>
</body>
</html>
